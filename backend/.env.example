# =============================================================================
# Easy Smart Monitor - API Backend v1.1.0
# Copie este arquivo para .env e ajuste os valores para seu ambiente.
# cp .env.example .env
# =============================================================================

# -----------------------------------------------------------------------------
# Ambiente
# -----------------------------------------------------------------------------
# Modo de execução da aplicação. "development" exibe mais logs; "production" otimiza performance.
NODE_ENV=development

# -----------------------------------------------------------------------------
# Gateway (Node.js / Fastify)
# -----------------------------------------------------------------------------
# Endereço em que o Gateway escuta (0.0.0.0 = todas as interfaces; use para Docker).
HOST=0.0.0.0
# Porta HTTP em que a API fica disponível (ex.: 8000 para http://localhost:8000).
PORT=8000

# Chave secreta usada para assinar e validar tokens JWT. Em produção use uma chave longa e aleatória (mín. 32 caracteres). Nunca use o valor padrão em produção.
SECRET_KEY=change-me-in-production-min-32-chars
# Tempo de vida do access token em minutos. Após esse tempo o cliente precisa renovar com o refresh token.
ACCESS_TOKEN_EXPIRE_MINUTES=15

# Número máximo de requisições permitidas por IP/dispositivo por minuto. Acima disso retorna 429 (Too Many Requests); abuso pode levar ao "Penalty Box" (bloqueio temporário).
RATE_LIMIT_PER_MINUTE=1000
# Origens permitidas para CORS (separadas por vírgula). URLs do frontend/dashboard que podem chamar a API pelo navegador.
CORS_ORIGINS=http://localhost:3000,http://localhost:8080

# Número máximo de sensores/itens aceitos em uma única requisição de telemetria bulk (/api/v1/telemetry/bulk). Requisições maiores são rejeitadas.
MAX_BULK_SIZE=10000

# Nível de detalhe dos logs do Gateway: debug (muito verboso), info, warn, error.
LOG_LEVEL=info

# -----------------------------------------------------------------------------
# Multi-tenant (Fase 0 - opcional)
# -----------------------------------------------------------------------------
# Habilita extração de contexto de tenant/org/workspace (não obrigatório por padrão).
MULTI_TENANT_ENABLED=false
# Se true, bloqueia requisições sem tenant_id (use somente após migração).
MULTI_TENANT_ENFORCE=false
# Headers opcionais para contexto (se não estiver no JWT).
TENANT_HEADER=x-tenant-id
ORGANIZATION_HEADER=x-organization-id
WORKSPACE_HEADER=x-workspace-id

# -----------------------------------------------------------------------------
# Banco de Dados (PostgreSQL / TimescaleDB)
# Usado pelo Gateway (auth, analytics) e pelos Workers (inserção de telemetria).
# -----------------------------------------------------------------------------
# URL de conexão com o banco. Se definida, tem precedência sobre POSTGRES_* abaixo. Formato: postgresql://USUARIO:SENHA@HOST:PORTA/NOME_DB
DATABASE_URL=postgresql://easysmart:SUA_SENHA@localhost:5432/easysmart_db

# Usado quando DATABASE_URL não está definida (monta a URL automaticamente).
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=easysmart
POSTGRES_PASSWORD=easysmart_password
POSTGRES_DB=easysmart_db

# Para Workers Python: a URL deve usar o driver asyncpg (ex.: postgresql+asyncpg://...). Em Docker use o nome do serviço (ex.: postgres) no host.
# DATABASE_URL=postgresql+asyncpg://easysmart:SUA_SENHA@postgres:5432/easysmart_db

# Tamanho do pool de conexões no Worker Python (quantas conexões manter abertas).
DATABASE_POOL_SIZE=20
# Quantas conexões extras podem ser criadas além do pool quando há pico de carga.
DATABASE_MAX_OVERFLOW=10

# -----------------------------------------------------------------------------
# Kafka
# Fila de mensagens: o Gateway envia "claim checks" (referências); os Workers consomem e processam.
# -----------------------------------------------------------------------------
# Endereço dos brokers Kafka (um ou mais, separados por vírgula). Em Docker use o nome do serviço (ex.: kafka:9092).
KAFKA_BROKERS=localhost:9092
# Nome do tópico onde o Gateway publica as mensagens de telemetria (claim check) e os Workers consomem.
KAFKA_TOPIC=telemetry.raw

# Identificador do grupo de consumidores. Workers com o mesmo GROUP_ID dividem a carga das partições.
KAFKA_GROUP_ID=telemetry-workers
# Quantas mensagens o Worker busca do Kafka por vez antes de processar (batch).
KAFKA_BATCH_SIZE=100
# Se false, o commit do offset só ocorre após processar com sucesso (recomendado para não perder dados).
KAFKA_AUTO_COMMIT=false

# -----------------------------------------------------------------------------
# Redis
# Usado para rate limit, penalty box (bloqueio temporário por abuso), blacklist (IP/dispositivo) e locks (evitar uploads simultâneos do mesmo dispositivo).
# -----------------------------------------------------------------------------
# URL de conexão com o Redis. Formato: redis://HOST:PORTA/ÍNDICE_DB (índice 0-15 por padrão).
REDIS_URL=redis://localhost:6379/0

# -----------------------------------------------------------------------------
# Storage - Claim Check Pattern
# O Gateway grava os payloads grandes (arquivos) aqui; envia só a referência (claim check) no Kafka. Os Workers leem o arquivo a partir dessa referência.
# -----------------------------------------------------------------------------
# Onde armazenar os arquivos: "minio" (S3-compatible) ou "local" (diretório no disco).
STORAGE_TYPE=minio

# Endereço do servidor MinIO (hostname ou IP). Em Docker use o nome do serviço (ex.: minio).
MINIO_ENDPOINT=localhost
# Porta da API do MinIO (não confundir com a porta do Console Web, geralmente 9001).
MINIO_PORT=9000
# Credenciais de acesso ao MinIO (equivalente a usuário e senha).
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
# Nome do bucket onde os arquivos de telemetria serão salvos (será criado se não existir).
MINIO_BUCKET=telemetry-raw
# Região S3 (obrigatório em alguns provedores; para MinIO local pode ser us-east-1).
MINIO_REGION=us-east-1
# Usar HTTPS para comunicação com o MinIO (true/false).
MINIO_USE_SSL=false

# Caminho no disco quando STORAGE_TYPE=local. O Gateway e os Workers precisam ter acesso de leitura/escrita a esse diretório.
STORAGE_LOCAL_PATH=/app/storage

# Se true, o Worker remove o arquivo do storage após processar com sucesso (economia de espaço).
DELETE_FILE_AFTER_PROCESSING=true
# Quantos dias manter arquivos que ainda não foram processados (útil para reprocessamento em caso de falha).
FILE_RETENTION_DAYS=7

# -----------------------------------------------------------------------------
# Workers Python
# Processam as mensagens do Kafka: baixam o arquivo do storage, validam e inserem no TimescaleDB.
# -----------------------------------------------------------------------------
# Quantas linhas de telemetria inserir por vez no banco (bulk insert). Valores maiores = menos round-trips, mais memória.
BULK_INSERT_BATCH_SIZE=1000
# Quantas vezes tentar novamente em caso de falha (ex.: banco indisponível) antes de desistir da mensagem.
MAX_RETRIES=3
# Segundos de espera entre cada tentativa de retry.
RETRY_DELAY=5
# Nível de log dos Workers: DEBUG, INFO, WARNING, ERROR.
LOG_LEVEL=INFO
# Formato de saída dos logs: "json" (estruturado, bom para produção) ou "console" (legível no terminal).
LOG_FORMAT=json
# Se true, ativa logs e comportamentos de diagnóstico (não usar em produção).
DEBUG=false

# -----------------------------------------------------------------------------
# Docker Compose
# Variáveis lidas pelo docker-compose ao subir os serviços. Defina no .env na raiz do backend; valores padrão são usados se omitidos.
# -----------------------------------------------------------------------------
# Senha do usuário PostgreSQL (serviço postgres). Deve coincidir com a usada em DATABASE_URL nos serviços gateway e worker.
# POSTGRES_PASSWORD=easysmart_password
# Usuário e senha do MinIO (serviço minio). Usados pelo gateway e worker para acessar o bucket.
# MINIO_ROOT_USER=minioadmin
# MINIO_ROOT_PASSWORD=minioadmin
# Mesma chave JWT do Gateway; em produção defina uma chave forte.
# SECRET_KEY=change-me-in-production-min-32-chars
# Não utilizado pela API atual (autenticação é via tabela users no banco). Mantido por compatibilidade com o compose.
# VALID_USERS={"admin":"admin123"}
